C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE COMPATIBILITYHID
OBJECT MODULE PLACED IN CompatibilityHID.OBJ
COMPILER INVOKED BY: D:\PrgEnv\MDK\core\C51\BIN\C51.EXE CompatibilityHID.C LARGE OPTIMIZE(8,SPEED) BROWSE NOAREGS DEBUG 
                    -OBJECTEXTEND TABS(2)

line level    source

   1          
   2          /********************************** (C) COPYRIGHT *******************************
   3          * File Name          :CompatibilityHID.C
   4          * Author             : WCH
   5          * Version            : V1.7
   6          * Date               : 2023/05/31
   7          * Description        : CH554æ¨¡æ‹ŸHIDå…¼å®¹è®¾å¤‡ï¼Œæ”¯æŒä¸­æ–­ä¸Šä¸‹ä¼ ï¼Œæ”¯æŒæ§åˆ¶ç«¯ç‚¹ä¸Šä¸‹ä¼ ï¼Œ
             -æ”¯æŒå…¨é€Ÿä¼ è¾“
   8          *********************************************************************************
   9          * Copyright (c) 2021 Nanjing Qinheng Microelectronics Co., Ltd.
  10          * Attention: This software (modified or not) and binary are used for 
  11          * microcontroller manufactured by Nanjing Qinheng Microelectronics.
  12          ********************************************************************************/
  13          
  14          #include "CH552.H"
  15          #include "Debug.H"
  16          #include "UART1.H"
  17          #include <stdio.h>
  18          #include <string.h>
  19          
  20          #define THIS_ENDP0_SIZE         64
  21          #define ENDP2_IN_SIZE           64
  22          #define ENDP2_OUT_SIZE          64
  23          
  24          UINT8X  Ep0Buffer[MIN(64,THIS_ENDP0_SIZE+2)] _at_ 0x0000;                          //ç«¯ç‚¹0 OUT&INç¼“å†²å
             -Œºï¼Œå¿…é¡»æ˜¯å¶åœ°å€
  25          UINT8X  Ep2Buffer[MIN(64,ENDP2_IN_SIZE+2)+MIN(64,ENDP2_OUT_SIZE+2)] _at_ MIN(64,THIS_ENDP0_SIZE+2);//ç«¯ç‚
             -¹2 IN&OUTç¼“å†²åŒº,å¿…é¡»æ˜¯å¶åœ°å€
  26          
  27          UINT8   SetupReq,Ready,UsbConfig;
  28          UINT16  SetupLen;
  29          PUINT8  pDescr;                                                                    //USBé…ç½®æ ‡å¿—
  30          USB_SETUP_REQ   SetupReqBuf;                                                       //æš‚å­˜SetupåŒ…
  31          #define UsbSetupBuf     ((PUSB_SETUP_REQ)Ep0Buffer)  
  32          
  33          
  34          #pragma  NOAREGS
  35          /*è®¾å¤‡æè¿°ç¬¦*/
  36          UINT8C DevDesc[18] = {
  37            0x12,        // bLength
  38            0x01,        // bDescriptorType (Device)
  39            0x10, 0x01,  // bcdUSB 1.10
  40            0x00,        // bDeviceClass (Use class information in the Interface Descriptors)
  41            0x00,        // bDeviceSubClass 
  42            0x00,        // bDeviceProtocol 
  43            THIS_ENDP0_SIZE,        // bMaxPacketSize0 64
  44            0x96, 0xAA,  // idVendor  0xAA96
  45            0x32, 0xAA,  // idProduct 0xAA32
  46            0x01, 0x00,  // bcdDevice 0.00
  47            0x01,        // iManufacturer (String Index)
  48            0x02,        // iProduct (String Index)
  49            0x00,        // iSerialNumber (String Index)
  50            0x01,        // bNumConfigurations 1 é…ç½®æ•°é‡
  51            // 18 bytes
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 2   

  52            };
  53          UINT8C CfgDesc[41] =
  54          { 
  55            0x09,        //   bLength
  56            0x02,        //   bDescriptorType (Configuration)
  57            0x29, 0x00,  //   wTotalLength 41
  58            0x01,        //   bNumInterfaces 1ï¼Œæ€»çš„æ¥å£æ•°é‡
  59            0x01,        //   bConfigurationValue,å½“å‰çš„æ ‡å¿—
  60            0x00,        //   iConfiguration (String Index)
  61            0xA0,        //   bmAttributes Remote Wakeup
  62            0x23,        //   bMaxPower 70mA
  63          
  64            0x09,        //   bLength
  65            0x04,        //   bDescriptorType (Interface)
  66            0x00,        //   bInterfaceNumber 0
  67            0x00,        //   bAlternateSetting
  68            0x02,        //   bNumEndpoints 2
  69            0x03,        //   bInterfaceClass
  70            0x00,        //   bInterfaceSubClassï¼Œæ˜¯å¦æ˜¯boot
  71            0x00,        //   bInterfaceProtocolï¼Œé¼ æ ‡è¿˜æ˜¯é”®ç›˜ï¼Œboot=0æ— æ•ˆ
  72            0x00,        //   iInterface (String Index)
  73          
  74            0x09,        //   bLength
  75            0x21,        //   bDescriptorType (HID)
  76            0x00, 0x01,  //   bcdHID 1.00
  77            0x21,        //   bCountryCode
  78            0x01,        //   bNumDescriptors
  79            0x22,        //   bDescriptorType[0] (HID)
  80            0x22, 0x00,  //   wDescriptorLength[0] 34
  81          
  82            0x07,        //   bLength
  83            0x05,        //   bDescriptorType (Endpoint)
  84            0x82,        //   bEndpointAddress (IN/D2H)
  85            0x03,        //   bmAttributes (Interrupt)
  86            ENDP2_IN_SIZE, 0x00,  //   wMaxPacketSize 64
  87            0x01,        //   bInterval 1 (unit depends on device speed)
  88          
  89            0x07,        //   bLength
  90            0x05,        //   bDescriptorType (Endpoint)
  91            0x02,        //   bEndpointAddress (OUT/H2D)
  92            0x03,        //   bmAttributes (Interrupt)
  93            ENDP2_OUT_SIZE, 0x00,  //   wMaxPacketSize 100
  94            0x01,        //   bInterval 1 (unit depends on device speed)
  95          
  96            // 41 bytes
  97          };
  98          /*å­—ç¬¦ä¸²æè¿°ç¬¦ ç•¥*/ 
  99          
 100          /*HIDç±»æŠ¥è¡¨æè¿°ç¬¦*/
 101          UINT8C HIDRepDesc[ ] =
 102          {
 103            0x06, 0x00, 0xFF,  // Usage Page (Vendor Defined 0xFF00)
 104            0x09, 0x01,        // Usage (0x01)
 105            0xA1, 0x01,        // Collection (Application)
 106            0x09, 0x02,        //   Usage (0x02)
 107            0x15, 0x00,        //   Logical Minimum (0)
 108            0x26, 0x00, 0xFF,  //   Logical Maximum (-256)
 109            0x75, 0x08,        //   Report Size (8)
 110            0x95, THIS_ENDP0_SIZE,        //   Report Count (64)
 111            0x81, 0x06,        //   Input (Data,Var,Rel,No Wrap,Linear,Preferred State,No Null Position)
 112            0x09, 0x02,        //   Usage (0x02)
 113            0x15, 0x00,        //   Logical Minimum (0)
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 3   

 114            0x26, 0x00, 0xFF,  //   Logical Maximum (-256)
 115            0x75, 0x08,        //   Report Size (8)
 116            0x95, THIS_ENDP0_SIZE,        //   Report Count (64)
 117            0x91, 0x06,        //   Output (Data,Var,Rel,No Wrap,Linear,Preferred State,No Null Position,Non-volatile
             -)
 118            0xC0              // End Collection
 119            
 120            // 34 bytes
 121          };
 122          
 123          unsigned char  code ManufacturerDes[]={
 124                                      10, 0x03,
 125                                      'Y', 0, 'R', 0, 'K', 0, 'B', 0
 126                                     };                                   //äº§å“å­—ç¬¦ä¸²æè¿°ç¬¦
 127          
 128          unsigned char  code ProductDes[]={
 129                                      16, 0x03,
 130                                      'S', 0, 'P', 0, 'Z', 0, '_', 0, 'C', 0, 'F', 0, 'G', 0
 131                                     };                                   //äº§å“å­—ç¬¦ä¸²æè¿°ç¬¦
 132          
 133          UINT8X UserEp2Buf[64];                                           //ç”¨æˆ·æ•°æ®å®šä¹‰
 134          UINT8 Endp2Busy = 0;
 135          UINT8 Endp2Recv = 0;
 136          UINT8 recv_len = 0;
 137          
 138          /*******************************************************************************
 139          * Function Name  : USBDeviceInit()
 140          * Description    : USBè®¾å¤‡æ¨¡å¼é…ç½®,è®¾å¤‡æ¨¡å¼å¯åŠ¨ï¼Œæ”¶å‘ç«¯ç‚¹é…ç½®ï¼Œä¸­æ–­å¼€å¯
 141          * Input          : None
 142          * Output         : None
 143          * Return         : None
 144          *******************************************************************************/
 145          void USBDeviceInit(void)
 146          {
 147   1        IE_USB = 0;
 148   1        USB_CTRL = 0x00;                                                           // å…ˆè®¾å®šUSBè®¾å¤‡æ¨¡å¼
 149   1        UDEV_CTRL = bUD_PD_DIS;                                                    // ç¦æ­¢DP/DMä¸‹æ‹‰ç”µé˜» 
 150   1          UDEV_CTRL &= ~bUD_LOW_SPEED;                                               //é€‰æ‹©å…¨é€Ÿ12Mæ¨¡å¼ï¼Œé
             -»˜è®¤æ–¹å¼
 151   1          USB_CTRL &= ~bUC_LOW_SPEED;
 152   1          UEP2_DMA = Ep2Buffer;                                                      //ç«¯ç‚¹2æ•°æ®ä¼ è¾“åœ°å€
 153   1          UEP2_3_MOD |= bUEP2_TX_EN | bUEP2_RX_EN;                                   //ç«¯ç‚¹2å‘é€æ¥æ”¶ä½¿èƒ½
 154   1          UEP2_3_MOD &= ~bUEP2_BUF_MOD;                                              //ç«¯ç‚¹2æ”¶å‘å„64å­—èŠ‚ç
             -¼“å†²åŒº
 155   1          UEP0_DMA = Ep0Buffer;                                                      //ç«¯ç‚¹0æ•°æ®ä¼ è¾“åœ°å€
 156   1          UEP4_1_MOD &= ~(bUEP4_RX_EN | bUEP4_TX_EN);                                //ç«¯ç‚¹0å•64å­—èŠ‚æ”¶å‘ç
             -¼“å†²åŒº
 157   1        USB_DEV_AD = 0x00;
 158   1        USB_CTRL |= bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN;                     // å¯åŠ¨USBè®¾å¤‡åŠDMAï¼Œåœ¨
             -ä¸­æ–­æœŸé—´ä¸­æ–­æ ‡å¿—æœªæ¸…é™¤å‰è‡ªåŠ¨è¿”å›NAK
 159   1        UDEV_CTRL |= bUD_PORT_EN;                                                  // å…è®¸USBç«¯å£
 160   1        USB_INT_FG = 0xFF;                                                         // æ¸…ä¸­æ–­æ ‡å¿—
 161   1        USB_INT_EN = bUIE_SUSPEND | bUIE_TRANSFER | bUIE_BUS_RST;
 162   1        IE_USB = 1;
 163   1      }
 164          
 165          /*******************************************************************************
 166          * Function Name  : Enp2BlukIn()
 167          * Description    : USBè®¾å¤‡æ¨¡å¼ç«¯ç‚¹2çš„æ‰¹é‡ä¸Šä¼ 
 168          * Input          : None
 169          * Output         : None
 170          * Return         : None
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 4   

 171          *******************************************************************************/
 172          void Enp2BlukIn()
 173          {
 174   1          memcpy( Ep2Buffer+MAX_PACKET_SIZE, UserEp2Buf, sizeof(UserEp2Buf));        //åŠ è½½ä¸Šä¼ æ•°æ®
 175   1          if( Ready )
 176   1          {
 177   2              UEP2_T_LEN = ENDP2_IN_SIZE;                                              //ä¸Šä¼ æœ€å¤§åŒ…é•¿åº¦
 178   2              UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;                  //æœ‰æ•°æ®æ—¶ä¸Šä¼ æ•°
             -æ®å¹¶åº”ç­”ACK
 179   2              Endp2Busy = 1;                                                           
 180   2          }
 181   1      }
 182          
 183          /*******************************************************************************
 184          * Function Name  : DeviceInterrupt()
 185          * Description    : CH559USBä¸­æ–­å¤„ç†å‡½æ•°
 186          *******************************************************************************/
 187          void    DeviceInterrupt( void ) interrupt INT_NO_USB using 1                    //USBä¸­æ–­æœåŠ¡ç¨‹åº,ä½
             -¿ç”¨å¯„å­˜å™¨ç»„1
 188          {
 189   1          UINT8  i, errflag;
 190   1          UINT16 len;
 191   1          if(UIF_TRANSFER)                                                            //USBä¼ è¾“å®Œæˆæ ‡å¿—
 192   1          {
 193   2              switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP))
 194   2              {
 195   3              case UIS_TOKEN_IN | 2:                                                  //endpoint 2# ç«¯ç‚¹æ‰¹é‡
             -ä¸Šä¼ 
 196   3                  UEP2_T_LEN = 0;                                                    //é¢„ä½¿ç”¨å‘é€é•¿åº¦ä¸€å
             -®šè¦æ¸…ç©º
 197   3                  UEP2_CTRL ^= bUEP_T_TOG;                                           //æ‰‹åŠ¨ç¿»è½¬
 198   3                  Endp2Busy = 0 ;
 199   3            UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //é»˜è®¤åº”ç­”NAK
 200   3                  break;
 201   3              case UIS_TOKEN_OUT | 2:                                                 //endpoint 2# ç«¯ç‚¹æ‰¹é‡
             -ä¸‹ä¼ 
 202   3                  if ( U_TOG_OK )                                                     // ä¸åŒæ­¥çš„æ•°æ®åŒ…å°
             -†ä¸¢å¼ƒ
 203   3                  {
 204   4                      len = USB_RX_LEN;                                               //æ¥æ”¶æ•°æ®é•¿åº¦ï¼Œæ•°æ®ä»Ep
             -2Bufferé¦–åœ°å€å¼€å§‹å­˜æ”¾
 205   4                      UEP2_CTRL ^= bUEP_R_TOG;                                        //æ‰‹åŠ¨ç¿»è½¬
 206   4                    Endp2Recv = 1;
 207   4                    recv_len = len;
 208   4      //                for ( i = 0; i < len; i ++ )
 209   4      //                {
 210   4      //                    Ep2Buffer[MAX_PACKET_SIZE+i] = Ep2Buffer[i];         // OUTæ•°æ®åŸæ ·å‘å›
 211   4      //                }
 212   4      //                UEP2_T_LEN = len;
 213   4      //                UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;       // å…è®¸ä¸Šä¼ 
 214   4                  }
 215   3                  break;
 216   3              case UIS_TOKEN_SETUP | 0:                                               //SETUPäº‹åŠ¡
 217   3                  UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK; 
 218   3            len = USB_RX_LEN;
 219   3                  if(len == (sizeof(USB_SETUP_REQ)))
 220   3                  {
 221   4                      SetupLen = ( (UINT16)UsbSetupBuf->wLengthH << 8 ) | UsbSetupBuf->wLengthL;
 222   4                      len = 0;                                                         // é»˜è®¤ä¸ºæˆåŠŸå¹¶ä¸”ä
             -¸Šä¼ 0é•¿åº¦
 223   4                      errflag = 0;
 224   4                      SetupReq = UsbSetupBuf->bRequest;             
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 5   

 225   4                      if ( ( UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK ) != USB_REQ_TYP_STANDARD )/*HIDç±»å‘½
             -ä»¤*/
 226   4                      {
 227   5                switch( SetupReq )                                             
 228   5                {
 229   6                  case 0x01:                                                  //GetReport
 230   6                    pDescr = UserEp2Buf;                                    //æ§åˆ¶ç«¯ç‚¹ä¸Šä¼ è¾“æ®
 231   6                    if(SetupLen >= THIS_ENDP0_SIZE)                         //å¤§äºç«¯ç‚¹0å¤§å°ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
 232   6                    {
 233   7                      len = THIS_ENDP0_SIZE;
 234   7                    }                          
 235   6                    else
 236   6                    {                          
 237   7                      len = SetupLen;                                   
 238   7                    }                          
 239   6                    break;
 240   6                  case 0x02:                                                   //GetIdle
 241   6                    break;  
 242   6                  case 0x03:                                                   //GetProtocol
 243   6                    break;        
 244   6                  case 0x09:                                                   //SetReport                    
 245   6                    break; 
 246   6                  case 0x0A:                                                   //SetIdle
 247   6                    break;  
 248   6                  case 0x0B:                                                   //SetProtocol
 249   6                    break;
 250   6                  default:
 251   6                    errflag = 0xFF;                                       /*å‘½ä»¤ä¸æ”¯æŒ*/         
 252   6                    break;
 253   6                } 
 254   5                if( SetupLen > len )
 255   5                {
 256   6                  SetupLen = len;    //é™åˆ¶æ€»é•¿åº¦
 257   6                }
 258   5                len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;   //æœ¬æ¬¡ä¼ è¾“é•¿åº¦
 259   5                memcpy(Ep0Buffer,pDescr,len);                                     //åŠ è½½ä¸Šä¼ æ•°æ®
 260   5                SetupLen -= len;
 261   5                pDescr += len;                  
 262   5                      }
 263   4                      else                                                             //æ ‡å‡†è¯·æ±‚
 264   4                      {
 265   5                          switch(SetupReq)                                             //è¯·æ±‚ç 
 266   5                          {
 267   6                          case USB_GET_DESCRIPTOR:
 268   6                              switch(UsbSetupBuf->wValueH)
 269   6                              {
 270   7                              case 1:                                                  //è®¾å¤‡æè¿°ç¬¦
 271   7                                  pDescr = DevDesc;                                    //æŠŠè®¾å¤‡æè¿°ç¬¦é€åˆ
             -°è¦å‘é€çš„ç¼“å†²åŒº
 272   7                                  len = sizeof(DevDesc);
 273   7                                  break;
 274   7                              case 2:                                                  //é…ç½®æè¿°ç¬¦
 275   7                                  pDescr = CfgDesc;                                    //æŠŠè®¾å¤‡æè¿°ç¬¦é€åˆ
             -°è¦å‘é€çš„ç¼“å†²åŒº
 276   7                                  len = sizeof(CfgDesc);
 277   7                                  break;
 278   7                              case 3:
 279   7                                  if (UsbSetupBuf->wValueL == 1) {
 280   8                                      pDescr = ManufacturerDes;
 281   8                                  } else if (UsbSetupBuf->wValueL == 2) {
 282   8                                      pDescr = ProductDes;
 283   8                                  } else {
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 6   

 284   8                                      errflag = 0xFF;   
 285   8                                    break;
 286   8                                  }
 287   7                                  len = pDescr[0];
 288   7                                  break;
 289   7                              case 0x22:                                               //æŠ¥è¡¨æè¿°ç¬¦
 290   7                                  pDescr = HIDRepDesc;                                 //æ•°æ®å‡†å¤‡ä¸Šä¼ 
 291   7                                  len = sizeof(HIDRepDesc);                            
 292   7                                  break;
 293   7                              default:
 294   7                                  errflag = 0xFF;                                          //ä¸æ”¯æŒçš„å‘½ä»¤æ
             -ˆ–è€…å‡ºé”™
 295   7                                  break;
 296   7                              }
 297   6                              if ( SetupLen > len )
 298   6                              {
 299   7                                  SetupLen = len;    //é™åˆ¶æ€»é•¿åº¦
 300   7                              }
 301   6                              len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;//æœ¬æ¬¡ä¼ è¾“é•¿åº
             -¦
 302   6                              memcpy(Ep0Buffer,pDescr,len);                            //åŠ è½½ä¸Šä¼ æ•°æ®
 303   6                              SetupLen -= len;
 304   6                              pDescr += len;
 305   6                              break;
 306   6                          case USB_SET_ADDRESS:
 307   6                              SetupLen = UsbSetupBuf->wValueL;                         //æš‚å­˜USBè®¾å¤‡åœ°å€
 308   6                              break;
 309   6                          case USB_GET_CONFIGURATION:
 310   6                              Ep0Buffer[0] = UsbConfig;
 311   6                              if ( SetupLen >= 1 )
 312   6                              {
 313   7                                  len = 1;
 314   7                              }
 315   6                              break;
 316   6                          case USB_SET_CONFIGURATION:
 317   6                              UsbConfig = UsbSetupBuf->wValueL;
 318   6                  if(UsbConfig)
 319   6                  {
 320   7                    Ready = 1;                                            //set configå‘½ä»¤ä¸€èˆ¬ä»£è¡¨usbæšä¸¾å®Œæˆ
             -çš„æ ‡å¿—
 321   7                  }
 322   6                              break;
 323   6                          case 0x0A:
 324   6                              break;
 325   6                          case USB_CLEAR_FEATURE:                                      //Clear Feature
 326   6                              if ( ( UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK ) == USB_REQ_RECIP_ENDP )// 
             -ç«¯ç‚¹
 327   6                              {
 328   7                                  switch( UsbSetupBuf->wIndexL )
 329   7                                  {
 330   8                                  case 0x82:
 331   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 332   8                                      break;
 333   8                                  case 0x81:
 334   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 335   8                                      break;
 336   8                                  case 0x02:
 337   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 338   8                                      break;
 339   8                                  default:
 340   8                                      errflag = 0xFF;                                       // ä¸æ”¯æŒçš„ç«¯ç‚
             -¹
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 7   

 341   8                                      break;
 342   8                                  }
 343   7                              }
 344   6                              else
 345   6                              {
 346   7                                  errflag = 0xFF;                                           // ä¸æ˜¯ç«¯ç‚¹ä¸æ”
             -¯æŒ
 347   7                              }
 348   6                              break;
 349   6                          case USB_SET_FEATURE:                                         /* Set Feature */
 350   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x00 )        /* è®¾ç½®è®¾å¤‡ */
 351   6                              {
 352   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 353   7                                  {
 354   8                                      if( CfgDesc[ 7 ] & 0x20 )
 355   8                                      {
 356   9                                          /* è®¾ç½®å”¤é†’ä½¿èƒ½æ ‡å¿— */
 357   9                                      }
 358   8                                      else
 359   8                                      {
 360   9                                          errflag = 0xFF;                                    /* æ“ä½œå¤±è´¥ */
 361   9                                      }
 362   8                                  }
 363   7                                  else
 364   7                                  {
 365   8                                      errflag = 0xFF;                                        /* æ“ä½œå¤±è´¥ */
 366   8                                  }
 367   7                              }
 368   6                              else if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x02 )    /* è®¾ç½®ç«¯ç‚¹ */
 369   6                              {
 370   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x00
             - )
 371   7                                  {
 372   8                                      switch( ( ( UINT16 )UsbSetupBuf->wIndexH << 8 ) | UsbSetupBuf->wIndexL )
 373   8                                      {
 374   9                                      case 0x82:
 375   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* è®¾ç½®ç«¯ç‚
             -¹2 IN STALL */
 376   9                                          break;
 377   9                                      case 0x02:
 378   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* è®¾ç½®ç«¯ç‚
             -¹2 OUT Stall */
 379   9                                          break;
 380   9                                      case 0x81:
 381   9                                          UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* è®¾ç½®ç«¯ç‚
             -¹1 IN STALL */
 382   9                                          break;
 383   9                                      default:
 384   9                                          errflag = 0xFF;                                     /* æ“ä½œå¤±è´¥ */
 385   9                                          break;
 386   9                                      }
 387   8                                  }
 388   7                                  else
 389   7                                  {
 390   8                                      errflag = 0xFF;                                         /* æ“ä½œå¤±è´¥ */
 391   8                                  }
 392   7                              }
 393   6                              else
 394   6                              {
 395   7                                  errflag = 0xFF;                                             /* æ“ä½œå¤±è´¥ */
 396   7                              } 
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 8   

 397   6                              break;
 398   6                          case USB_GET_STATUS:
 399   6                              Ep0Buffer[0] = 0x00;
 400   6                              Ep0Buffer[1] = 0x00;
 401   6                              if ( SetupLen >= 2 )
 402   6                              {
 403   7                                  len = 2;
 404   7                              }
 405   6                              else
 406   6                              {
 407   7                                  len = SetupLen;
 408   7                              }
 409   6                              break;
 410   6                          default:
 411   6                              errflag = 0xFF;                                                  //æ“ä½œå¤±è´¥
 412   6                              break;
 413   6                          }
 414   5                      }
 415   4                  }
 416   3                  else
 417   3                  {
 418   4                      errflag = 0xFF;                                                          //åŒ…é•¿åº¦é”™è¯¯
 419   4                  }
 420   3                  if(errflag == 0xFF)
 421   3                  {
 422   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
 423   4                  }
 424   3                  else if(len <= THIS_ENDP0_SIZE)                                         //ä¸Šä¼ æ•°æ®æˆ–è€…çŠ
             -¶æ€é˜¶æ®µè¿”å›0é•¿åº¦åŒ…
 425   3                  {
 426   4                      UEP0_T_LEN = len;
 427   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//é»˜è®¤æ•°æ®åŒ…æ˜¯DA
             -TA1ï¼Œè¿”å›åº”ç­”ACK
 428   4                  }
 429   3                  else
 430   3                  {
 431   4                      UEP0_T_LEN = 0;  //è™½ç„¶å°šæœªåˆ°çŠ¶æ€é˜¶æ®µï¼Œä½†æ˜¯æå‰é¢„ç½®ä¸Šä¼ 0é•¿åº¦æ•°æ®åŒ…ä
             -»¥é˜²ä¸»æœºæå‰è¿›å…¥çŠ¶æ€é˜¶æ®µ
 432   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//é»˜è®¤æ•°æ®åŒ…æ˜¯DA
             -TA1,è¿”å›åº”ç­”ACK
 433   4                  }
 434   3                  break;
 435   3              case UIS_TOKEN_IN | 0:                                                      //endpoint0 IN
 436   3                  switch(SetupReq)
 437   3                  {
 438   4                  case USB_GET_DESCRIPTOR:
 439   4                  case HID_GET_REPORT:              
 440   4                      len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;     //æœ¬æ¬¡ä¼ è¾“é•¿åº¦
 441   4                      memcpy( Ep0Buffer, pDescr, len );                                   //åŠ è½½ä¸Šä¼ æ•°æ®
 442   4                      SetupLen -= len;
 443   4                      pDescr += len;
 444   4                      UEP0_T_LEN = len;
 445   4                      UEP0_CTRL ^= bUEP_T_TOG;                                            //åŒæ­¥æ ‡å¿—ä½ç¿»è½
             -¬
 446   4                      break;
 447   4                  case USB_SET_ADDRESS:
 448   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 449   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 450   4                      break;
 451   4                  default:
 452   4                      UEP0_T_LEN = 0;                                                      //çŠ¶æ€é˜¶æ®µå®Œæˆä
             -¸­æ–­æˆ–è€…æ˜¯å¼ºåˆ¶ä¸Šä¼ 0é•¿åº¦æ•°æ®åŒ…ç»“æŸæ§åˆ¶ä¼ è¾“
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 9   

 453   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 454   4                      break;
 455   4                  }
 456   3                  break;
 457   3              case UIS_TOKEN_OUT | 0:  // endpoint0 OUT
 458   3                  len = USB_RX_LEN;
 459   3                  if(SetupReq == 0x09)
 460   3                  {
 461   4                      if(Ep0Buffer[0])
 462   4                      {
 463   5                          printf("Light on Num Lock LED!\n");
 464   5                      }
 465   4                      else if(Ep0Buffer[0] == 0)
 466   4                      {
 467   5                          printf("Light off Num Lock LED!\n");
 468   5                      }
 469   4                  }
 470   3                  UEP0_CTRL ^= bUEP_R_TOG;                                     //åŒæ­¥æ ‡å¿—ä½ç¿»è½¬    
 471   3                  break;
 472   3              default:
 473   3                  break;
 474   3              }
 475   2              UIF_TRANSFER = 0;                                                           //å†™0æ¸…ç©ºä¸­æ–­
 476   2          }
 477   1          else if(UIF_BUS_RST)                                                                 //è®¾å¤‡æ¨¡å¼USB
             -æ€»çº¿å¤ä½ä¸­æ–­
 478   1          {
 479   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 480   2              UEP2_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 481   2              USB_DEV_AD = 0x00;
 482   2              UIF_SUSPEND = 0;
 483   2              UIF_TRANSFER = 0;
 484   2              Ready = 0;
 485   2          Endp2Busy = 0;
 486   2              UIF_BUS_RST = 0;                                                             //æ¸…ä¸­æ–­æ ‡å¿—
 487   2          }
 488   1          else if (UIF_SUSPEND)                                                                 //USBæ€»çº¿æŒ‚èµ
             -·/å”¤é†’å®Œæˆ
 489   1          {
 490   2              UIF_SUSPEND = 0;
 491   2              if ( USB_MIS_ST & bUMS_SUSPEND )                                             //æŒ‚èµ·
 492   2              {
 493   3      #ifdef DE_PRINTF
 494   3                  printf( "zz" );                                                          //ç¡çœ çŠ¶æ€
 495   3      //             while ( XBUS_AUX & bUART0_TX )
 496   3      //             {
 497   3      //                 ;    //ï¿½È´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
 498   3      //             }
 499   3      #endif
 500   3      //             SAFE_MOD = 0x55;
 501   3      //             SAFE_MOD = 0xAA;
 502   3      //             WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO;                                   //USBæˆ–è€…RXD0æœ
             -‰ä¿¡å·æ—¶å¯è¢«å”¤é†’
 503   3      //             PCON |= PD;                                                               //ç¡çœ 
 504   3      //             SAFE_MOD = 0x55;
 505   3      //             SAFE_MOD = 0xAA;
 506   3      //             WAKE_CTRL = 0x00;
 507   3              }
 508   2          }
 509   1          else {                                                                             //æ„å¤–çš„ä¸­æ–­,ä
             -¸å¯èƒ½å‘ç”Ÿçš„æƒ…å†µ
 510   2              USB_INT_FG = 0xFF;                                                             //æ¸…ä¸­æ–­æ ‡å¿—
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 10  

 511   2      //      printf("UnknownInt  N");
 512   2          }
 513   1      }
*** WARNING C280 IN LINE 189 OF CompatibilityHID.C: 'i': unreferenced local variable
 514          
 515          main()
 516          {
 517   1          UINT8 i;
 518   1      
 519   1          CfgFsys( );                                                           //CH559æ—¶é’Ÿé€‰æ‹©é…ç½®
 520   1          mDelaymS(5);                                                          //ä¿®æ”¹ä¸»é¢‘ç­‰å¾…å†…éƒ¨æ™¶æŒ¯
             -ç¨³å®š,å¿…åŠ   
 521   1          mInitSTDIO( );                                                        //ä¸²å£0åˆå§‹åŒ–
 522   1      #ifdef DE_PRINTF
 523   1          printf("start ...\n");
 524   1      #endif  
 525   1        UART1Init( );                                                           //ä¸²å£1åˆå§‹åŒ–
 526   1          memset(UserEp2Buf, 0, sizeof(UserEp2Buf));
 527   1          USBDeviceInit();                                                      //USBè®¾å¤‡æ¨¡å¼åˆå§‹åŒ–
 528   1          EA = 1;                                                               //å…è®¸å•ç‰‡æœºä¸­æ–­   
 529   1          UEP1_T_LEN = 0;                                                       //é¢„ä½¿ç”¨å‘é€é•¿åº¦ä¸€å®šè¦
             -æ¸…ç©º
 530   1          UEP2_T_LEN = 0;                                                       //é¢„ä½¿ç”¨å‘é€é•¿åº¦ä¸€å®šè¦
             -æ¸…ç©º
 531   1          Ready = 0;
 532   1          while(1)
 533   1          {
 534   2              if(Ready)
 535   2              {
 536   3                  // while(Endp2Busy);                                           //å¦‚æœå¿™ï¼ˆä¸Šä¸€åŒ…æ•°æ®æ²¡æœ‰ä¼
             - ä¸Šå»ï¼‰ï¼Œåˆ™ç­‰å¾…ã€‚
 537   3                  // Enp2BlukIn();
 538   3                  if (Endp2Recv) { // USBæ”¶åˆ°æ•°æ®ï¼Œé€šè¿‡UARTå‘å‡ºå»
 539   4                    for (i=0; i < recv_len; i++) {
 540   5                      CH554UART1SendByte(Ep2Buffer[i]);                                     //å¹¶é€šè¿‡ä¸²å£1å‘å›å»
 541   5                    }
 542   4                    Endp2Recv = 0;
 543   4                  }
 544   3      //            if (U1RI!=0) { // UART æ”¶åˆ°æ•°æ®(ç»„ç»‡æˆåŒ…å)ï¼Œé€šè¿‡USBå‘å‡ºå»
 545   3      //              dat = CH554UART1RcvByte();                                //ç¨‹åºæ­»ç­‰ï¼Œç›´åˆ°æ”¶åˆ°ä¸€ä¸ªå­—è
             -Š‚
 546   3      //              printf("%d", dat);
 547   3      //              if (usb_pkg_s == 0) {
 548   3      //                if (dat == 0xff) { // ç¬¬ä¸€ä¸ªæ•°æ®æ˜¯å¸§å¤´
 549   3      //                  usb_pkg_s = 1; // å¼€å§‹æ¥å—ä¸€ä¸ªåŒ…
 550   3      //                  usb_pkg_i = 0;
 551   3      //                  memset(UserEp2Buf, 0, sizeof(UserEp2Buf));
 552   3      //                } else {
 553   3      //                  usb_pkg_i = 0;
 554   3      //                }
 555   3      //              } else {
 556   3      //                if (usb_pkg_i == 0) {
 557   3      //                  usb_pkg_len = dat; // ç¬¬äºŒä¸ªæ•°æ®æ˜¯æ•°æ®é•¿åº¦
 558   3      //                  if (usb_pkg_len > ENDP2_IN_SIZE) { // æ— æ•ˆ
 559   3      //                    usb_pkg_s = 0;
 560   3      //                    usb_pkg_i = 0;
 561   3      //                  }
 562   3      //                } else if (usb_pkg_i-1 >= usb_pkg_len) { // æœ€åä¸€ä¸ªæ•°æ®æ˜¯å¸§å°¾
 563   3      //                  if (dat == 0xfe) { // å¸§å°¾æ­£ç¡®æ‰å‘é€
 564   3      //                    while(Endp2Busy);
 565   3      //                    Enp2BlukIn();
 566   3      //                  }
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 11  

 567   3      //                  usb_pkg_s = 0;
 568   3      //                  usb_pkg_i = 0;
 569   3      //                } else {
 570   3      //                  UserEp2Buf[usb_pkg_i-1] = dat; // å¡«å……æ•°æ®
 571   3      //                }
 572   3      //                usb_pkg_i++;
 573   3      //              }
 574   3      //            }
 575   3              } else {
 576   3              mDelaymS(100);                                                 //æ¨¡æ‹Ÿå•ç‰‡æœºåšå…¶å®ƒäº‹
 577   3              }
 578   2              
 579   2          }
 580   1      }
 581          
 582          #if UART1_INTERRUPT
 583          /*******************************************************************************
 584          * Function Name  : UART1Interrupt(void)
 585          * Description    : UART1 ä¸­æ–­æœåŠ¡ç¨‹åº
 586          *******************************************************************************/
 587          void UART1Interrupt( void ) interrupt INT_NO_UART1 using 1                       //ä¸²å£1ä¸­æ–­æœåŠ¡ç¨‹å
             -º,ä½¿ç”¨å¯„å­˜å™¨ç»„1
 588          {
 589   1            UINT8 dat;
 590   1          UINT8 usb_pkg_i = 0;
 591   1          UINT8 usb_pkg_s = 0;
 592   1          UINT8 usb_pkg_len = 0;
 593   1        if(U1RI)
 594   1        {
 595   2          dat = SBUF1;
 596   2          U1RI = 0;
 597   2                    printf("%d", dat);
 598   2                    if (usb_pkg_s == 0) {
 599   3                      if (dat == 0xff) { // ç¬¬ä¸€ä¸ªæ•°æ®æ˜¯å¸§å¤´
 600   4                        usb_pkg_s = 1; // å¼€å§‹æ¥å—ä¸€ä¸ªåŒ…
 601   4                        usb_pkg_i = 0;
 602   4                        memset(UserEp2Buf, 0, sizeof(UserEp2Buf));
 603   4                      } else {
 604   4                        usb_pkg_i = 0;
 605   4                      }
 606   3                    } else {
 607   3                      if (usb_pkg_i == 0) {
 608   4                        usb_pkg_len = dat; // ç¬¬äºŒä¸ªæ•°æ®æ˜¯æ•°æ®é•¿åº¦
 609   4                        if (usb_pkg_len > ENDP2_IN_SIZE) { // æ— æ•ˆ
 610   5                          usb_pkg_s = 0;
 611   5                          usb_pkg_i = 0;
 612   5                        }
 613   4                      } else if (usb_pkg_i-1 >= usb_pkg_len) { // æœ€åä¸€ä¸ªæ•°æ®æ˜¯å¸§å°¾
 614   4                        if (dat == 0xfe) { // å¸§å°¾æ­£ç¡®æ‰å‘é€
 615   5                          while(Endp2Busy);
 616   5                          Enp2BlukIn();
 617   5                        }
 618   4                        usb_pkg_s = 0;
 619   4                        usb_pkg_i = 0;
 620   4                      } else {
 621   4                        UserEp2Buf[usb_pkg_i-1] = dat; // å¡«å……æ•°æ®
 622   4                      }
 623   3                      usb_pkg_i++;
 624   3                    }
 625   2        }
 626   1      }
 627          #endif
C51 COMPILER V9.60.0.0   COMPATIBILITYHID                                                  05/06/2024 01:42:00 PAGE 12  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1715    ----
   CONSTANT SIZE    =    185    ----
   XDATA SIZE       =     83       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
